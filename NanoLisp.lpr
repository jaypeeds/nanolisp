(* Scan Page 40 Col. 1 *)
PROGRAM nanolisp2(INPUT, OUTPUT);

CONST
  MAXCHAINE=12; (* LES NOMS AURONT 12 CARACTERES MAXIMUM *)
  QT='''';
  SPC=' ';
  PG='(';
  PD=')';
  DOT='.';
  VIDE='';
  FD='->';
  TAB=CHR(9);   (* Séparateurs non-imprimables *)
  CR=CHR(13);
  LF=CHR(10);


TYPE
  SMALLSTRING=STRING[MAXCHAINE];
  TYPTOKEN=(PGAUCHE, PDROITE,APOS, SYMBOLE);
  (* 5 TYPES DE CARACTERES LUS : PARENTHESE GAUCHE, DROITE, APOSTROPHE
     ET TOUS LES AUTRES *)

  TYPEBASE=(ATOME, LISTE);

  SGRAPHE = ^NOEUD;

  NOEUD=RECORD
    CASE SORTE :TYPEBASE OF
      ATOME:
        (PNAME:^SMALLSTRING; VAL: SGRAPHE);
      LISTE:
        (CAR,CDR: SGRAPHE);
    END;
    (* AVEC TOUS CES POINTEURS LE NOEUD DE BASE NE FAIT QUE 6 OCTETS !!! *)
  PTOBLIST=^TYPOBLIST;
    (* LA LISTE DES ATOMES N'EST PAS ICI UNE LISTE LISP *)

  TYPOBLIST=RECORD
    ATOME: SGRAPHE;
    LIEN: PTOBLIST
  END;

  (* Pour la compatibilité *)
  INTERACTIVE=TEXT;

VAR (* ---- Globales ---- *)
  NILE, TRU, AQUOTE, S, M, PSOURCE:SGRAPHE;
  OBLIST: PTOBLIST;
  FINSESS, ERREUR, TRACE: BOOLEAN;

PROCEDURE PRINT(S:SGRAPHE); FORWARD;
(***** FONCTIONS UTILITAIRES ******)

FUNCTION FERREUR(MESSAGE:STRING; S:SGRAPHE) :SGRAPHE;
(* IMPRIME LE MESSAGE D'ERREUR ET LA LISTE OU L'ATOME EN CAUSE *)
BEGIN
  WRITE('*** ERREUR : ', MESSAGE, FD);
  PRINT(S);
  WRITELN('***');
  ERREUR:= TRUE;
  FERREUR:= NILE;
END;

FUNCTION FNULL(S:SGRAPHE): BOOLEAN;
BEGIN
  FNULL:=(S=NIL) OR (S=NILE);
END;

PROCEDURE OBPRINT;
(* IMPRIME LA LISTE DES ATOMES CONNUS *)
VAR
  OBCOUR: PTOBLIST;

BEGIN
  OBCOUR:=OBLIST;
  WHILE (OBCOUR<>NIL) DO
    BEGIN
      IF OBCOUR^.ATOME^.SORTE=ATOME THEN
        WRITE(OBCOUR^.ATOME^.PNAME^,SPC);
        OBCOUR:=OBCOUR^.LIEN;
    END;
    WRITELN;
END;

FUNCTION NOUVATOM(POSITION:PTOBLIST;NOM:SMALLSTRING):PTOBLIST;
(* INSERE UN NOUVEL ATOME DANS LA LISTE A LA SUITE DE "POSITION" *)
VAR
  OBPREC,OBSUIV: PTOBLIST;
BEGIN
  (* ON REPERE LES 2 VOISINS *)
  OBPREC:=POSITION;
  (* Scan Page 40 Col. 2 *)
  OBSUIV:=OBPREC^.LIEN;
  (* ON CREE LE NOUVEL ATOME *)
  NEW(POSITION);
  NEW(POSITION^.ATOME);
  POSITION^.ATOME^.SORTE:= ATOME;
  NEW(POSITION^.ATOME^.PNAME);
  POSITION^.ATOME^.PNAME^:=NOM;
  POSITION^.ATOME^.VAL:= NIL;
  (* ON RACCROCHE DANS LA CHAINE *)
  OBPREC^.LIEN:=POSITION;
  POSITION^.LIEN:=OBSUIV;
  (* ON REND L'ATOME CREE *)
  NOUVATOM:=POSITION;
END;

FUNCTION FINDATOM(NOM: SMALLSTRING) : SGRAPHE;
(* TROUVE L'ATOME DU NON DONNE OU REND NIL *)
VAR
  CONT:BOOLEAN;
  PTCOUR: PTOBLIST;

BEGIN
  PTCOUR :=OBLIST;
  CONT:=TRUE;
  WHILE (PTCOUR<>NIL) AND CONT DO
  BEGIN
    CONT:=(PTCOUR^.ATOME^.PNAME^<>NOM);
    IF CONT THEN PTCOUR:=PTCOUR^.LIEN;
  END;
  IF PTCOUR=NIL THEN
    FINDATOM:=NILE
  ELSE
    FINDATOM:=PTCOUR^.ATOME;
END;

(**********FONCTIONS DE BASE ***********)
FUNCTION FCAR(S:SGRAPHE) : SGRAPHE;
(* LE CAR *)
BEGIN
  IF FNULL(S) THEN
    FCAR:=NILE
  ELSE
    IF S^.SORTE=LISTE THEN
      FCAR:=S^.CAR
    ELSE
      FCAR:=FERREUR('CAR',S);
END;

FUNCTION FCDR(S:SGRAPHE):SGRAPHE; (* LE CDR *)

BEGIN
  IF FNULL(S) THEN
    FCDR:=NILE
  ELSE
    IF S^.SORTE=LISTE THEN
      FCDR:=S^.CDR
    ELSE
      FCDR:= FERREUR('CDR',S);
END;

FUNCTION FATOM(S:SGRAPHE) : SGRAPHE;
(* REND TRU SI LE SGRAPHE EST UN ATOME *)

BEGIN
  IF S^.SORTE=ATOME THEN
    FATOM:=TRU
  ELSE
    FATOM:=NILE;
END;

FUNCTION FEQ(S1, S2: SGRAPHE): SGRAPHE;
(* TESTE LEGALITE DES POINTEURS *)

BEGIN
  IF S1=S2 THEN
    FEQ:=TRU
  ELSE
    FEQ:=NILE;
END;

FUNCTION FCONS(S1,S2: SGRAPHE): SGRAPHE;
(* LE CONS *)
(* S2 doit être une liste ou l'atome NILE *)
VAR
  NEWS: SGRAPHE;
  (* Scan Page 41 Col. 1 *)

BEGIN
  IF (S2^.SORTE=ATOME) AND NOT FNULL(S2) THEN
    FCONS:=FERREUR('CONS', S2)
  ELSE
  BEGIN
    NEW(NEWS);
    NEWS^.SORTE:=LISTE;
    NEWS^.CAR:=S1;
    NEWS^.CDR:=S2;
    FCONS:=NEWS;
  END;
END;

FUNCTION FDE (S: SGRAPHE): SGRAPHE;
  (* DONNE UN NOM A UNE FONCTION *)
  BEGIN
    S^.CAR^.VAL:=FCONS(FINDATOM('LAMBDA'),FCDR(S));
    FDE:=FCAR(S);
  END;

(*********** PROCEDURES D'ENTREE-SORTIES *****)
FUNCTION FREAD(VAR INFILE: INTERACTIVE): SGRAPHE;
(* LE NOM READ EST DEJA RESERVE PAR PASCAL *)
VAR
  (*LUGRAPHE:SGRAPHE;*)
  TAMPON:CHAR; (* DERNIER CARACTERE LU *)
  TOKEN: TYPTOKEN; (* TYPE DU CARACTERE LU *)

  FUNCTION READATOM(VAR TOKEN: TYPTOKEN): SGRAPHE;

  VAR
    PTCOUR, PTPREC: PTOBLIST; (* NECESSAIRES SI UN NOUVEL ATOME EST NOMME *)
    CONT:BOOLEAN;
    LUCHAINE: SMALLSTRING;
    INTER: STRING[1]; (*POUR PERMETTRE L'APPLICATION DE LA FONCTION CONCAT *)
  BEGIN
    LUCHAINE:=VIDE;
    INTER:=SPC;

  (* INITIALISATIONS *)
  IF TAMPON=SPC THEN
  BEGIN
    (* TOUT CE QUI A ETE LU PRECEDMMENT A ETE TRAITE*)
    (* 1 = ON AVALE LES BLANCS *)
    WHILE (NOT EOF(INFILE)) AND (TAMPON in [SPC, TAB, CR, LF]) DO READ(INFILE, TAMPON);
    (* 2 = ON LIT JUSQU'AU PREMIER SEPARATEUR *)
    WHILE NOT (EOF(INFILE)
      OR (TAMPON IN [PG, PD, SPC, TAB, CR, LF, QT])
      OR (LENGTH(LUCHAINE) >= MAXCHAINE)) DO
      BEGIN INTER[1]:= TAMPON;
        LUCHAINE:=CONCAT(LUCHAINE, INTER);
        READ (INFILE,TAMPON);
      END(*WHILE*)
    (* ON A MAINTENANT LE NOM LU OU RIEN DANS LUCHAINE ET LE SEPARATEUR DANS TAMPON *)
  END; (* IF TAMPON *)

  IF (LUCHAINE=VIDE) THEN
     BEGIN
    (* CAS OU UN SEPARATEUR EST LU EN PREMIER *)
    (* TRANSFER DANS LUCHAINE *)
      INTER[1]:=TAMPON;
      LUCHAINE:=CONCAT(LUCHAINE,INTER);
      TAMPON:=SPC;
    END;

    (* INITIALISATIONS *)
    READATOM:=NILE;
    IF LUCHAINE=PG     THEN TOKEN:=PGAUCHE ELSE
    IF LUCHAINE=PD     THEN TOKEN:=PDROITE ELSE
    IF LUCHAINE=QT     THEN TOKEN:=APOS ELSE
      BEGIN
        (* Scan Page 41 Col. 2 *)
        (*UN NOM A ETE LU - EST-IL CONNU ? *)
        TOKEN:=SYMBOLE;
        PTPREC:=NIL;
        PTCOUR:=OBLIST;
        CONT:=TRUE;
        WHILE (PTCOUR<>NIL) AND CONT DO
        BEGIN
          CONT:=(PTCOUR^.ATOME^.PNAME^<>LUCHAINE);
          IF CONT THEN
          BEGIN
            PTPREC:=PTCOUR;
            PTCOUR:=PTCOUR^.LIEN;
          END;
        END;
        IF PTCOUR=NIL THEN
        (* C'EST UN NOUVEAU NOM -> ON L'ENREGISTRE *)
          PTCOUR:=NOUVATOM(PTPREC, LUCHAINE);

        READATOM:=PTCOUR^.ATOME;
      END; (*ELSE LUCHAINE*)
  END;

  FUNCTION READ1(DANSLISTE: BOOLEAN): SGRAPHE;
  (* READ1 LIT 2 TYPES DE "PHRASES":
    ATOMES : MOTS EN DEHORS DE PARANTHESE
    LISTES : SUITE DE MOTS ENTRE PARENTHESES *)
  VAR
    LUGRAPHE, R1, R2: SGRAPHE;

  BEGIN
    LUGRAPHE:=READATOM(TOKEN);
    CASE TOKEN OF
      PGAUCHE: IF DANSLISTE THEN
        BEGIN
          (* LECTURE DU CAR ET DU CDR *)
          R1:=READ1(TRUE);
          R2:=READ1(TRUE);
          (* ASSEMBLAGE *)
          READ1:=FCONS(R1,R2);
        END ELSE
        (* ON DEMARRE LA LECTURE D'UNE NOUVELLE LISTE *)
          READ1:=READ1(TRUE);
      PDROITE: READ1:=NILE; (* ON A TERMINE LA LISTE *)
      APOS: IF DANSLISTE THEN
        BEGIN (* ON LIT UN TERME DE TYPE ATOME ET UN DE TYPE LISTE *)
          R1:=READ1(FALSE);
          R2:=READ1(TRUE);
          (* ON LES ASSEMBLE *)
          READ1:=FCONS(FCONS(AQUOTE,FCONS(R1,NILE)), R2);
        END ELSE
          BEGIN
            (*ON LIT UN TERME DE TYPE ATOME SEULEMENT *)
            R1:=READ1(FALSE);
        (* ON LE REND SOUS LA FORME (QUOTE) (ATOME) *)
            READ1:=FCONS(AQUOTE,FCONS(R1,NILE));
          END;
      SYMBOLE: IF DANSLISTE THEN
        BEGIN
          (* ON LIT L'ATOME ET ON CONTINUE JUSQU'A FIN DE LA LISTE *)
          R1:=READ1(TRUE);
          READ1:=FCONS(LUGRAPHE,R1);
        END ELSE (* LECTURE D'UN ATOME SEUL *)
          READ1 :=LUGRAPHE;
    END; (* CASE *)
  END;
(* Corps de FREAD *)
BEGIN
  TAMPON:=SPC;
  FREAD:=READ1(FALSE);
END; (*FREAD*)

PROCEDURE PRINT(S:SGRAPHE);
  (* POUR IMPRIMER DES LISTES *)
  (* Scan Page 42 Col. 1 *)
  VAR
     BLANCPRINT: BOOLEAN;
     PROCEDURE PRINT1(S:SGRAPHE);
       PROCEDURE PRINTATOM(S:SGRAPHE);
         BEGIN
           IF BLANCPRINT THEN WRITE(SPC);
           (* LE NOM DE L'ATOME *)
           WRITE(S^.PNAME^);
           BLANCPRINT:=FALSE;
         END;
       (* Corps de PRINT1 *)
       BEGIN
          IF FNULL(S) THEN
             PRINTATOM(NILE)
          ELSE
              IF S^.SORTE=ATOME THEN
                 BEGIN
                 (* IMPRESSION DE L'ATOME SEUL *)
                    PRINTATOM(S);
                    BLANCPRINT:=TRUE;
                 END ELSE
                 BEGIN
                    IF FCAR(S)=AQUOTE THEN
                    BEGIN
                      (* TRANSFORMATION INVERSE DE LA LECTURE :
                      ((QUOTE) (ATOME)) => '(ATOME)
                      *)
                      WRITE(SPC,QT);
                      PRINT(FCAR(FCDR(S))); (* ON REPART COMME POUR UNE NOUVELLE LISTE *)
                    END ELSE
                    BEGIN
                      IF (NOT FNULL(S^.CAR)) AND (S^.CAR^.SORTE=LISTE) AND (S^.CAR^.CAR <> AQUOTE) THEN
                         WRITE(SPC,PG); (* SUITE DE LISTE *)

                      PRINT1(FCAR(S)); (* IMPRESSION DU CAR *)

                      IF FNULL(FCDR(S)) THEN
                         WRITE(PD,SPC) (* FIN DE LISTE *)
                      ELSE
                         PRINT1(FCDR(S)); (* IMPRESSION DU CDR *)
                    END; (* NOT QUOTE *)
                 END;
       END;
  (* Corps de PRINT *)
   BEGIN
     BLANCPRINT:=FALSE;
     IF (S^.SORTE=LISTE) AND (S^.CAR <> AQUOTE) THEN
        WRITE(SPC,PG);
     PRINT1(S);
   END;

PROCEDURE PAIRLIS(VAR NOMS, VALS: SGRAPHE);
(* LES VALEURS PASSEES SONT MOMENTANEMENT ASSOCIEES AUX NOMS
  CEUX-CI RETROUVERONT LEURS ANCIENNES VALEURS PAR
  L'OPERATION INVERGE.
  PATRLIS N'EST APPELEE QUE LORS DE L'EXECUTION DE LAMDDA
*)
VAR
  SAVE: SGRAPHE;

BEGIN
  IF ERREUR THEN EXIT(*PAIRLIS*);
  IF TRACE THEN BEGIN
    WRITELN;
    WRITE('PAIRLIS ', FD, PG);
    (*IF NOT FNULL(NOMS) THEN*)
        PRINT(NOMS);
    WRITE(DOT);
    (*IF NOT FNULL(VALS) THEN *)
        PRINT(VALS);
    WRITELN(PD);
  END;
  IF NOMS^.SORTE=LISTE THEN
    BEGIN
      (* Va au fond de la liste d'abord puis revient vers la tête *)
      PAIRLIS(NOMS^.CDR,VALS^.CDR);
      SAVE:=NOMS^.CAR^.VAL;
      NOMS^.CAR^.VAL:=FCAR(VALS);
      VALS^.CAR:=SAVE;
    END ELSE
      IF NOT FNULL(NOMS) THEN
        BEGIN
          SAVE:=NOMS^.VAL;
          NOMS^.VAL:=VALS;
          (* Scan Page 42 Col. 2 *)
          VALS:=SAVE;
        END;
END;

FUNCTION EVAL(E:SGRAPHE):SGRAPHE;FORWARD;
FUNCTION FLOAD (FILENAME:SGRAPHE):SGRAPHE;
VAR
  INFILE: INTERACTIVE;

BEGIN
  IF TRACE THEN
    BEGIN
      WRITELN;
      WRITE('LOAD',FD);
      PRINT(FILENAME);
      WRITELN;
  END;

  IF (FILENAME^.SORTE=ATOME) AND (FILENAME^.PNAME<>NIL) THEN
    BEGIN
      (* Ajouté pour compatibilité Free Pascal *)
      (*L'EXTENSION .NLSP EST TOUJOURS AJOUTEE *)
      ASSIGN(INFILE,CONCAT(FILENAME^.PNAME^,'.NLSP'));
      RESET (INFILE);
      WHILE NOT EOF (INFILE) DO
        BEGIN
          WRITELN;
          WRITE('=',SPC);
          PRINT(EVAL(FREAD(INFILE)));
        END;
        CLOSE(INFILE);
        FLOAD:=TRU;
    END ELSE
      FLOAD:=FERREUR('LOAD',FILENAME);
END;

FUNCTION APPLISTE(S:SGRAPHE): SGRAPHE;
(* EXECUTE UNE SUITE D'EXPRESSIONS ET REND LA DERNIERE *)

BEGIN
  REPEAT
    IF ERREUR THEN
      BEGIN
        APPLISTE:=NILE;
        EXIT(*APPLISTE*);
      END;
    APPLISTE:=EVAL(FCAR(S));
    S:=FCDR(S);
  UNTIL ERREUR OR (S=NILE)
END;

FUNCTION APPLY(FN,ARGS:SGRAPHE):SGRAPHE;
(* EXECUTE UNE FONCTION AVEC LES ARGUMENTS PASSES *)
(*VAR
  SAVE:SGRAPHE;*)

BEGIN
  IF ERREUR THEN
    BEGIN
      APPLY:=FN;
      EXIT(*APPLY*);
    END;
  IF TRACE THEN
    BEGIN
      WRITELN;
      WRITE('APPLY',FD);
      PRINT(FN);
      WRITE(FD,SPC);
      PRINT(ARGS);
      (* WRITELN;*)
    END;
    (* TODO FNULL(FN) ? *)
    IF (FN=NILE) THEN
      APPLY:=FERREUR('APPLY', FN)
    ELSE IF (FN^.SORTE=ATOME) THEN
      (* FONCTIONS PREDEFINIES *)
      IF FN^.PNAME^='CAR'       THEN APPLY:=FCAR(FCAR(ARGS)) ELSE
      IF FN^.PNAME^='CDR'       THEN APPLY:=FCDR(FCAR(ARGS)) ELSE
      IF FN^.PNAME^='CONS'      THEN APPLY:=FCONS(FCAR(ARGS), FCAR(FCDR(ARGS))) ELSE
      IF FN^.PNAME^='ATOM'      THEN APPLY:=FATOM(FCAR(ARGS)) ELSE
      IF FN^.PNAME^='EQ'        THEN APPLY:=FEQ(FCAR(ARGS),FCAR(FCDR(ARGS))) ELSE
      (* IF FN^.PNAME^='READ'      THEN APPLY:=FREAD(INPUT) ELSE *)
      IF FN^.PNAME^='PRINT'     THEN BEGIN
                                        PRINT(FCAR(ARGS));
                                        APPLY:=FCAR(ARGS);
                                     END ELSE
      IF FN^.PNAME^='OBLIST'    THEN BEGIN
                                        APPLY:=NILE;
                                        OBPRINT;
                                     END ELSE
      IF FN^.PNAME^='QUIT'      THEN BEGIN
                                        APPLY:=NILE;
                                        FINSESS:=TRUE;
                                     END ELSE
      IF FN^.PNAME^='LOAD'      THEN APPLY:=FLOAD(FCAR(ARGS)) ELSE
            (* CE N'EST PAS NE FONCTION PREDEFINIE
            ON OBTIENT SA DEFINITION PAR EVAL ET ON APPLIOUE *)
      APPLY:=APPLY(EVAL(FN),ARGS)
  ELSE
    (*FN EST UNE LISTE*)
    IF FCAR(FN)=FINDATOM('LAMBDA') THEN
      BEGIN
        (* Scan Page 43 Col. 1 *)
        PAIRLIS(FN^.CDR^.CAR,ARGS); (* ON DONNE LEUR VALEUR AUX PARAMETRES *)
        APPLY:=APPLISTE(FCDR(FCDR(FN)));
        PAIRLIS(FN^.CDR^.CAR, ARGS);(* ON RESTAURE LEURS ANCIENNES VALEURS *)
      END
    ELSE
        APPLY:=FERREUR('APPLY', FN);
END; (*APPLY*)

FUNCTION EVLIS(ARGS: SGRAPHE): SGRAPHE;
(* EVALUE LES COMPOSANTS D'UNE LISTE *)

BEGIN
  IF FNULL(ARGS) THEN
    EVLIS:=NILE
  ELSE
    EVLIS:=FCONS(EVAL(FCAR(ARGS)), EVLIS(FCDR(ARGS)));
END;

FUNCTION EVCOND(L:SGRAPHE):SGRAPHE;
(*EXECUTE UNE CONDITIONNELLE *)

BEGIN
  IF NOT FNULL(EVAL(FCAR(FCAR(L)))) THEN
    BEGIN
      IF TRACE THEN
         WRITE(FD,'EVAL CAR', SPC);
      EVCOND:=APPLISTE(FCDR(FCAR(L)));
      END
  ELSE
    IF NOT FNULL(FCDR(L)) THEN
      BEGIN
        IF TRACE THEN
           WRITE(FD,'EVAL CDR', SPC);
        EVCOND:=EVCOND(FCDR(L));
      END
    ELSE
      EVCOND:=NILE;
    END;

FUNCTION FSETQ(S:SGRAPHE): SGRAPHE;
BEGIN
  IF (S^.CAR^.SORTE=ATOME) AND (S^.CAR<>NILE) THEN
    BEGIN
      S^.CAR^.VAL:=FCAR(EVLIS(FCDR(S)));
      FSETQ:=S^.CAR^.VAL;
    END
  ELSE
    BEGIN
      FSETQ:=FERREUR('SETQ',S);
    END;
END;

FUNCTION EVAL(E:SGRAPHE): SGRAPHE;
(* L'EVALUATEUR :
  SI LE PARAMETRE EST UN ATOME - ) REND SA VALEUR SINON
  SI LE CAR EST UN ATOME
  SI C'EST UNE "FONCTION SPECIALE"
    (PARAMETRES NON EVALUES) -> EXECUTION
  SINON -) APPELLE APPLY POUR SON EXECUTION AVEC LA LISTE
    EVALUEE DES ARGUMENTS *)
VAR S:SGRAPHE;

BEGIN
  IF ERREUR THEN
    BEGIN
      EVAL:=E;
      EXIT(*EVAL*);
    END;
  IF TRACE THEN
    BEGIN
      WRITELN;
      WRITE('EVAL',FD);
      PRINT(E);
      (* WRITELN;*)
    END;
  IF E^.SORTE=ATOME THEN
    IF (E^.VAL=NIL) OR FNULL(E) THEN
      BEGIN
        EVAL :=FERREUR('EXPRESSION INDEFINIE' , E);
        EXIT(*EVAL*);
      END
    ELSE
      EVAL:=E^.VAL
  ELSE BEGIN
    S:=FCAR(E);
    IF S^.SORTE=ATOME           THEN
      IF S^.PNAME^='QUOTE'      THEN EVAL:=FCAR(FCDR(E)) ELSE
      IF S^.PNAME^='COND'       THEN EVAL:=EVCOND(FCDR(E)) ELSE
      IF S^.PNAME^='TRACE'      THEN BEGIN
                                      TRACE:=TRUE;
                                      EVAL:=FINDATOM('TRACE') END ELSE
      IF S^.PNAME^='UNTRACE'    THEN BEGIN
                                      TRACE:=FALSE;
                                      (* Scan Page 43 Col. 2 *)
                                      EVAL:=FINDATOM('UNTRACE') END ELSE
      IF S^.PNAME^='SETQ'       THEN EVAL:=FSETQ(FCDR(E)) ELSE
      IF S^.PNAME^='DE'         THEN EVAL:=FDE(FCDR(E))
      ELSE
        EVAL:=APPLY(S,EVLIS(FCDR(E)))
      END;
END;

(******* INITIALISATION ******)
PROCEDURE INIT;

VAR
  OBCOUR, PPSOURCE:PTOBLIST;

BEGIN
  TRACE:=FALSE;
  (* CREATION DU PREMIER ATOME *)
  NEW(NILE);
  NEW(NILE^.PNAME);
  NILE^.PNAME^:='()';
  NEW(OBCOUR);
  OBCOUR^.ATOME:=NILE;
  (* ON CONSERVE L'ENTREE DANS LA LISTE AVEC OBLIST *)
  OBLIST:=OBCOUR;
  OBCOUR:=NOUVATOM(OBCOUR, 'T'); TRU:=OBCOUR^.ATOME;
  OBCOUR:=NOUVATOM(OBCOUR, 'QUOTE'); AQUOTE:=OBCOUR^.ATOME;
  OBCOUR:=NOUVATOM(OBCOUR, 'CAR');
  OBCOUR:=NOUVATOM(OBCOUR, 'CDR');
  OBCOUR:=NOUVATOM(OBCOUR, 'CONS');
  OBCOUR:=NOUVATOM(OBCOUR, 'ATOM');
  OBCOUR:=NOUVATOM(OBCOUR, 'EQ');
  OBCOUR:=NOUVATOM(OBCOUR, 'LAMBDA');
  OBCOUR:=NOUVATOM(OBCOUR, 'READ');
  OBCOUR:=NOUVATOM(OBCOUR, 'PRINT');
  OBCOUR:=NOUVATOM(OBCOUR, 'COND');
  OBCOUR:=NOUVATOM(OBCOUR, 'TRACE');
  OBCOUR:=NOUVATOM(OBCOUR, 'UNTRACE');
  OBCOUR:=NOUVATOM(OBCOUR, 'SETQ');
  OBCOUR:=NOUVATOM(OBCOUR, 'LOAD');
  OBCOUR:=NOUVATOM(OBCOUR, 'OBLIST');
  OBCOUR:=NOUVATOM(OBCOUR, 'QUIT');

  TRU^.VAL:=TRU;
  NILE^.VAL:=NILE;
  NEW(PPSOURCE);
  PPSOURCE:=NOUVATOM(PPSOURCE, './SOURCE');
  PSOURCE:=PPSOURCE^.ATOME;
END;(*INIT)

* Corps du programme principal *)
BEGIN
    FINSESS:=FALSE;
    INIT;
    (* PAGE(OUTPUT); *)
    WRITELN('****************************');
    WRITELN('         NANO-LISP');
    WRITELN;
    WRITELN('         JM HUSSON');
    WRITELN('****************************');
    WRITE('Source: '); PRINT(PSOURCE);WRITELN('.NLSP');

    REPEAT
      WRITE('? ');
      M:=FLOAD(PSOURCE);
      WRITELN;
      ERREUR :=FALSE;
      S:=EVAL(M);
      IF NOT (FINSESS OR ERREUR) THEN
      BEGIN
        WRITELN; WRITE('# ');
        PRINT(S);
      END;
      WRITELN;
    UNTIL FINSESS OR ERREUR;
END.

